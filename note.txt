ep9 - 
  used proj (IdentityServer, ApiOne, ApiTwo)
  in this episode, IdentityServer is used for OAuth & OIDC. ApiOne is created as an API, and ApiTwo is created to act
  as a client API calling ApiOne using the token created using ClientCredential. ApiTwo is registered in IdentityServer as
  a Client that has access to scope ApiOne. In ApiTwo/Home/Index, it first creates
  httpClient and calls the IdentityServer to get the token using Client Credential flow
  then it calls the ApiOne/secret [Authorize] with this token added to the header
  For ApiOne, in the ConfigureServices, it tells, it is authenticating from the IdentityServer using Bearer token (oidc)
  therefore, any [Authorize] method in ApiOne must have a token dealt out from IdentityServer with scope (ApiOne)

ep10 -
  used proj (IdentityServer, MvcClient)
  in this episode, it just prepares and create MvcClient to use authorization-code flow for openID connect for ep11

ep11 - 
  used proj (IdentitiyServer, MvcClient)
  in this episode, log-in and register page is created. So MVC Client page home/secret [Authorize] is first accessed, 
  it will be automatically directed to IdentityServer's login page (since the authorization-code flow is used)
  If the user is successfully registered or logged-in, it user is authenticated and will be re-directed to 
  mvcClient/home/secret page

ep12 - 
  used proj (IdentityServer, ApiOne, MvcClient)
  first, it describes the cookies created. 
  AspNetCore.Cookie - this is a cookie on the MvcClient client's side
    created and split to 1 and 2 because it's too big. it holds id token and access token. removing this
    cookie and refresh to home/seret won't force you to re-login since below cookie still exist for Identity Server.
    if you refresh /home/secret, it will still travel to identityServer/connect/authorize page and come back wihtout 
    needng user to enter credential
  IdentityServer.Cookie - holds any authentiated user info for current session stored on Identity Server side. 
    if this cookie is deleted, it will ask you to re-login only if you are missing above cookie also.
    otherwise, the current session info for the MvcClient is stored in the cookie, so it won't even redirect you to
    IdentityServer/connect/authorize page
  Idsrv.session - this cookie tells which identityi server current session is associated with. In this case the session
    is connected to the IdentityServer, but it can be google or facebook
  in this episode, custom claims are added and shows what needs to be done to have custom claims added to id-token
  also, it shows how to add/remove certain claims in the httpContext. 
  also, it shows how to add/remove claims from the IDToken and instead show them only in HttpContext.claims (requires 2 trips)
  also, it shows how to add/remove scopes in startup.cs for mvcClient
  also, it shows how to call ApiOne using the access token from MvcClient
  also, it shows how to add the claims to either ID Token or Access token

ep13 - 
  used proj (IdentityServer, MvcClient, ApiOne)
  In this episode, he implements the refresh-token using IdentityServer4

ep14 -
  used proj (IdentityServer, JavascriptClient)
  in this episode, he implements the Implicit call to get the ID-Token and Access token from IdentityServer
  also, it shows the flow from 1. click on sign-in, 2. re-direct to IdentityServer's login page, 3. if successfully logged-in
  it will re-direct to IdentityServer's internal sign-in and 4. redirect back to the client's redirect url with the
  tokens added to the url as # 5. Javascript will receive and parse the tokens (ID and Access) and store to browser's memory
  -Sign-in.js - custom way to build the callback url with all params to call IdentitiyServer's login function
  -Sign-in-callback.js - parses the string received from the IdentityServer and store ID and Access token to browsers memory

ep15 - 
  used proj (IdentityServer, JavascriptClient, ApiOne)
  in this episode, he shows how to implement signin re-direct using oidc-client.js instead of writing custom one as ep14
  still using the Implicit flow
  first, ApiOne is modified to allow Cors connections from the browser in the startup.cs
  next, in IdentityServer project, configuration.cs modified to add AllowedCorsOrigins of the addresss of the client ip addr
  next, removed custom .js files sign-in.js and sign-in-callback.js and added main.js to use Oidc.UserManager
  The flow is 1. User click on sign-in button, 2. .js will call the IdentityServer using the oidc.usermanager
  3. user logs-in on IdentityServer page, 4. IdentityServer will verify and logs-in, and redirects to the re-direct page
  with the ID and Access tokens, 5. Signin.cshtml simply displays the result on the console log and redirects to the index
  6. also the main.js adds the Bearer token to the header Authorization using Axios, 
  7. user clicks on the 'call apione' button, 8. use Axio (as httpContext) to call the API (Url) and will get it successfully 

ep16 -
  used proj (IdentityServer, JavascriptClient, ApiOne)
  first, it enabled LocalStorage (so user can close the browser and reopen to connect to ApiOne without authnticating
  for persistance.
  next, he shows how to add new claims
  last, he shows how to auto-request for the token if the access token is expired, so the user won't have to re-enter
  the password. This is done via oidc.userManager.signInSilent() and this is only called if the 401 is returned. This
  makes the implicit-flow more usable without annoying the user to re-authenticate every hour or so.
  
  LocalStorage - shared among all tabs, and survives refresh, browser close, and OS reboot, (5MB storage), 
    client-side readonly, less older browser support, no expiration, plain text and not secure
  SessionStorage - only accessible from same tab. survives refresh, but not browser close or OS reboot (5-10MB storage)
    client-side readonly, less older browser support
  Cookie - both client and server side read support, 4KB size, expiry can be set per cookie, purposed for server,
    if httpOnly flag=true, it will be secured and cannot be read by client

ep 17 -
  used proj (IdentityServer, MvcClient, JavascriptClient ApiOne)
  this episode teaches how to convert in-memory storage to sql server storage using EF
  before anything, he calls (dotnet tool install --global dotnet-ef) to install the EF tool
  next, he calls (dotnet ef migrations add [name of the migration] -c [class name] -o [output path]). this command
  will create migration files so it can be tracked in source control. This migration is simply a middle piece between
  the database table and the model class. this needs to be updated as the model changes
  next, he calls (dotnet ef database update -c [class name for context created by migration]). this command will
  create the database
  Db-Scripts.txt shows all above commands for migrations and database
  
ep 18 -
  used proj (IdentityServer, MvcClient, JavascriptClient, ApiOne)
  in thie episode, he shows how to add the log-out on both mvcClient and JsClient
  nest, he explains how to apply certificate to the IdentityServer. using dev mode won't require it, but in production
  environment, certificate is required, and no longer needing .AddDeveloperSigningCredential();

ep 19 -
  used proj (IdentityServer, MvcClient, ApiOne)
  in this episode, he shows how to authenticate via Facebook. First, he shows how to get the Facebook OAuth login registered.
  Then he shows how to register the user using the Facebook OpenID, and that information is stored on the local SQL Server
  and won't require the manual registration by the user. Once registered, you can close the MVC Client and reopen, and click
  on the FAcebook, it will use cached info in the cookie to log you in again automatically, and so is the MvcClient.
  You can call the ApiOne api with this login as well.
  I added Google as another external authenticator by adding a pacakge Microsoft.aspnetcore.authentication.google
  These middlewares created by MS work as below
  1. from MvcClient project, when I try to access the secret controller end point [Authorize], it redirects me to IdentitySvr
  2. From IdentityServer AuthController, login endpoint is called with below redirect URI (URI created by IdentitySvr)
    "/connect/authorize/callback?client_id=client_id_mvc
    &redirect_uri=https%3A%2F%2Flocalhost%3A44322%2Fsignin-oidc
    &response_type=code
    &scope=openid%20rc.scope%20ApiOne%20ApiTwo%20offline_access
    &code_challenge=etCFPbmxcr3qwkUtSRu789qEtCYds3a-QwGoapOEpXk
    &code_challenge_method=S256
    &response_mode=form_post
    &nonce=637405791220096234.NmMyZWJmOTgtMzIzNy00NDkzLTk00YzY1LTliYjMtMWRjM2ExYTA1ODNj
    &state=CfDJ8Kaa-wFM9w9Kno6yk1nQK9rRT3SMPGBXUUZCNqsMw
    &x-client-SKU=ID_NETSTANDARD2_0
    &x-client-ver=5.5.0.0"
  3. login view will display the external login buttons on the fly
  4. once you click on external authenticator button (either Google or Facebook), it will call EXternalLogin method
  5. Challenge() will open Google/Facebook login page for oidc
  6. IdentiySvr automatically attaches the signin-google or signin-facebook at the end of the redirect URL of the identitySvr
  7. so if the Identity server is https://localhost:44305, you must register https://localhost:44305/signin-google or facebook
  8. after sign-in successfully, the callback function ExternalLoginCallback is called 
  9. within this callback function, it first checks to see if sign-in. if success, it will return you back to the home/secret
  10. if you fail to sign-in, mean you are not registered. it will direct you to register page with username pre-populated
  11. if you click on register button, it will try to create new user (register), and add login, and sign-in and to home/secret
  
  one thing to remeber is, external auth (facebook or google) is only for authenticating. In this example, the MvcClient, once
  you are authenticated, you can go into the [Authorize] end-points of MvcClient project. This MvcClient accessing ApiOne using
  ClientCredential is separate issue (nothing todo with external auth. Accessing ApiOne is done by using client ID, client
  secret, redirect URL, and scope that are pre-registered in configuration.cs, so the ID Token or Access Token that is used to
  call ApiOne has no user info (such as google or facebook)
  
  once you login using facebook or google, login is stored in the database, so until it expires, you won't need to re-login

ep 20 -
  used proj (IdentityServer, MvcClient, JavaScript Client, ApiOne)
  in this episode, PKCE is used to enhance the security of Javascript Client. This won't do much for MvcClient or any kind
  of web app that can securely call to get the ID Token or Access Token, but JavaScript client, it needs more security.
  Once it calls the IS, it receives a code, and that code is used by oidc_client to request Access and ID tokens.
  He is brief in explaining, so need to do more research on this PKCE to trully understand this.

ep 21 -
  used proj (IdentityServer, WPF Client, ApiOne)
  in this episode, he create new WPF client and shows how it can leverage IS to get the user authenticated, and also get the
  Access token to call the ApiOne.
  OnButtonClick on the wpf form, it will 1. create oidc client with the information already registered in IS configuration.cs
  2. call oidcClient.LoginAsync() this will call the IS AuthController.Login() 3. login form is displayed on the WPF browser
  4. user can login with the pwd or external auth (google/facebook) 5. once successfully logged in, oidcClient.LoginAsync()
  called in step #2 will receive result back. that means the redirectUri passed into oidcClient is not really used or used
  in the background to process and parse the result sent by the IS and create the result object and returns it. all dirty
  work in sending the code and receiving the result and parsing the tokens are done behind the back by the oidcClient
  6. we get the User object from the result to determine if the login was successful or not. 7. we can get the accessToken 
  from the result object, and use that to call the ApiOne
  
ep 22 -

